use std::sync::Arc;
use polywrap_core::{error::Error, invoke::Invoker};
use polywrap_plugin::module::PluginModule;
use serde::{Serialize, Deserialize};
use super::types::*;
pub use polywrap_plugin::base_impl_plugin_module;

#[macro_export]
macro_rules! impl_plugin_module {
    ($plugin_type:ty) => {
        $crate::wrap::module::base_impl_plugin_module!(
            $plugin_type,
            {{#moduleType}}
            {{#methods}}
            ({{#toLower}}{{name}}{{/toLower}}, $crate::wrap::module::Args{{#toUpper}}{{name}}{{/toUpper}}),
            {{/methods}}
            {{/moduleType}}
        );
    };
}

{{#moduleType}}
{{#methods}}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Args{{#toUpper}}{{name}}{{/toUpper}} {
    {{#arguments}}
    {{#serdeKeyword}}{{#toLower}}{{name}}{{/toLower}}{{/serdeKeyword}}pub {{#detectKeyword}}{{#toLower}}{{name}}{{/toLower}}{{/detectKeyword}}: {{#toWasm}}{{toGraphQLType}}{{/toWasm}},
    {{/arguments}}
}
{{/methods}}
{{/moduleType}}

pub trait Module: PluginModule {
  {{#moduleType}}
  {{#methods}}
  fn {{#toLower}}{{name}}{{/toLower}}(&self, args: &Args{{#toUpper}}{{name}}{{/toUpper}}, invoker: Arc<dyn Invoker>) -> Result<{{#return}}{{#toWasm}}{{toGraphQLType}}{{/toWasm}}{{/return}}, Error>;
  {{^last}}

  {{/last}}
  {{/methods}}
  {{/moduleType}}
}
