import * as Types from "..";

import {
{{#methods}}
  deserialize{{name}}Args,
  serialize{{name}}Result{{^last}},{{/last}}
{{/methods}}
} from "./serialization";

import {
  wrap_invoke_args,
  __wrap_invoke_result,
  __wrap_invoke_error,
  wrap_load_env,
  InvokeArgs,
} from "@polywrap/wasm-as";

export abstract class IModule {
  {{#hasEnv}}private _env: Types.Env | undefined;{{/hasEnv}}

  {{#methods}}
  abstract {{#detectKeyword}}{{name}}{{/detectKeyword}}(
    args: Types.Args_{{#detectKeyword}}{{name}}{{/detectKeyword}}
  ): {{#return}}{{#toWasm}}{{toGraphQLType}}{{/toWasm}}{{/return}};

  {{/methods}}
  {{#hasEnv}}
  public get env(): Types.Env {
    return this._env;
  }

  public setEnv(env: Types.Env): void {
    this._env = env;
  }
  {{/hasEnv}}

  public _wrap_invoke(method_size: u32, args_size: u32, env_size: u32): bool {
    const args: InvokeArgs = wrap_invoke_args(
      method_size,
      args_size
    );

    {{#methods}}
    {{^first}}else {{/first}}if (args.method == "{{name}}") {
      const result = this.{{name}}Wrapped(args.args, env_size);
      __wrap_invoke_result(
        changetype<u32>(result),
        result.byteLength
      );
      return true;
    }
    {{/methods}}
    else {
      const message = String.UTF8.encode(
        `Could not find invoke function "${args.method}"`
      );
      __wrap_invoke_error(
        changetype<u32>(message),
        message.byteLength
      );
      return false;
    }
  }

  {{#methods}}
  private {{name}}Wrapped(argsBuf: ArrayBuffer, env_size: u32): ArrayBuffer {
    {{#env}}
    {{#required}}
    if (env_size == 0) {
      throw new Error("Environment is not set, and it is required by method '{{name}}'")
    }
    
    const envBuf = wrap_load_env(env_size);
    this.setEnv(Types.Env.fromBuffer(envBuf));
    {{/required}}
    {{^required}}
    if (env_size > 0) {
      const envBuf = wrap_load_env(env_size);
      this.setEnv(Types.Env.fromBuffer(envBuf));
    }
    {{/required}}
    {{/env}}
    {{#arguments.length}}
    const args = deserialize{{name}}Args(argsBuf);
    {{/arguments.length}}

    const result = this.{{#detectKeyword}}{{name}}{{/detectKeyword}}({{#arguments.length}}
      {
        {{#arguments}}
        {{#detectKeyword}}{{name}}{{/detectKeyword}}: args.{{#detectKeyword}}{{name}}{{/detectKeyword}}{{^last}},{{/last}}
        {{/arguments}}
      }{{/arguments.length}}{{^arguments.length}}{}{{/arguments.length}}
    );
    return serialize{{name}}Result(result);
  }
  {{^last}}

  {{/last}}
  {{/methods}}
}