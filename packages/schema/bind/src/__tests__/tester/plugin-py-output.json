{
  "output": {
    "entries": [
      {
        "type": "File",
        "name": "module.py",
        "data": "/// NOTE: This is an auto-generated file.\n///       All modifications will be overwritten.\n\nfrom abc import ABC, abstractmethod\nfrom typing import TypeVar, Generic\n\nimport .types as types\n\nfrom polywrap_core import InvokerClient, MaybeAsync, UriPackageOrWrapper\nfrom polywrap_plugin import PluginModule\n\nTConfig = TypeVar(\"TConfig\")\n\n\n\nclass ArgsmoduleMethod(TypedDict):\n    str: Types.String;\n    optStr: Optional[Union[Types.String, None]];\n    en: Types.CustomEnum;\n    optEnum: Optional[Union[Types.CustomEnum, None]];\n    enumArray: List[Types.CustomEnum];\n    optEnumArray: Optional[Union[List[Union[Types.CustomEnum, None]], None]];\n    map: GenericMap[Types.String, Types.Int];\n    mapOfArr: GenericMap[Types.String, List[Types.Int]];\n    mapOfMap: GenericMap[Types.String, GenericMap[Types.String, Types.Int]];\n    mapOfObj: GenericMap[Types.String, Types.AnotherType];\n    mapOfArrOfObj: GenericMap[Types.String, List[Types.AnotherType]];\n\nclass ArgsobjectMethod(TypedDict):\n    object: Types.AnotherType;\n    optObject: Optional[Union[Types.AnotherType, None]];\n    objectArray: List[Types.AnotherType];\n    optObjectArray: Optional[Union[List[Union[Types.AnotherType, None]], None]];\n\nclass ArgsoptionalEnvMethod(TypedDict):\n    object: Types.AnotherType;\n    optObject: Optional[Union[Types.AnotherType, None]];\n    objectArray: List[Types.AnotherType];\n    optObjectArray: Optional[Union[List[Union[Types.AnotherType, None]], None]];\n\nclass Argsif(TypedDict):\n    if: Types._else;\n\nclass Module(Generic[TConfig], PluginModule[TConfig]) {\n  @abstractmethod\n  def moduleMethod(\n    args: ArgsmoduleMethod,\n    client: InvokerClient[UriPackageOrWrapper],\n    env: None\n  ): MaybeAsync<Types.Int>;\n\n  @abstractmethod\n  def objectMethod(\n    args: ArgsobjectMethod,\n    client: InvokerClient[UriPackageOrWrapper],\n    env: types.Env\n  ): MaybeAsync<Union[Types.AnotherType, None]>;\n\n  @abstractmethod\n  def optionalEnvMethod(\n    args: ArgsoptionalEnvMethod,\n    client: InvokerClient[UriPackageOrWrapper],\n    env: Optional[types.Env] = None\n  ): MaybeAsync<Union[Types.AnotherType, None]>;\n\n  @abstractmethod\n  def if(\n    args: Argsif,\n    client: InvokerClient[UriPackageOrWrapper],\n    env: None\n  ): MaybeAsync<Types._else>;\n}\n"
      },
      {
        "type": "File",
        "name": "types.py",
        "data": "### NOTE: This is an auto-generated file.\n###       All modifications will be overwritten.\n\nfrom typing import TypedDict, Optional\nfrom enum import Enum\n\nfrom polywrap_core import InvokerClient, Uri, UriPackageOrWrapper\n\nUInt = int;\nUInt8 = int;\nUInt16 = int;\nUInt32 = int;\nInt = int;\nInt8 = int;\nInt16 = int;\nInt32 = int;\nBytes = bytes;\nBigInt = str;\nBigNumber = str;\nJson = str;\nString = str;\nBoolean = bool;\n\n### Env START ###\nclass Env(TypedDict):\n    prop: Types.String\n    optProp: Optional[Union[Types.String, None]]\n    optMap: Optional[Union[GenericMap[Types.String, Optional[Types.Int]], None]]\n### Env END ###\n\n### Objects START ###\nclass CustomType(TypedDict):\n    str: Types.String\n    optStr: Optional[Union[Types.String, None]]\n    u: Types.UInt\n    optU: Optional[Union[Types.UInt, None]]\n    u8: Types.UInt8\n    u16: Types.UInt16\n    u32: Types.UInt32\n    i: Types.Int\n    i8: Types.Int8\n    i16: Types.Int16\n    i32: Types.Int32\n    bigint: Types.BigInt\n    optBigint: Optional[Union[Types.BigInt, None]]\n    bignumber: Types.BigNumber\n    optBignumber: Optional[Union[Types.BigNumber, None]]\n    json: types.Json\n    optJson: Optional[Union[types.Json, None]]\n    bytes: Types.Bytes\n    optBytes: Optional[Union[Types.Bytes, None]]\n    boolean: Types.Boolean\n    optBoolean: Optional[Union[Types.Boolean, None]]\n    uArray: List[Types.UInt]\n    uOptArray: Optional[Union[List[Types.UInt], None]]\n    optUOptArray: Optional[Union[List[Union[Types.UInt, None]], None]]\n    optStrOptArray: Optional[Union[List[Union[Types.String, None]], None]]\n    uArrayArray: List[List[Types.UInt]]\n    uOptArrayOptArray: List[Union[List[Union[Types.UInt32, None]], None]]\n    uArrayOptArrayArray: List[Union[List[List[Types.UInt32]], None]]\n    crazyArray: Optional[Union[List[Union[List[List[Union[List[Types.UInt32], None]]], None]], None]]\n    object: Types.AnotherType\n    optObject: Optional[Union[Types.AnotherType, None]]\n    objectArray: List[Types.AnotherType]\n    optObjectArray: Optional[Union[List[Union[Types.AnotherType, None]], None]]\n    en: Types.CustomEnum\n    optEnum: Optional[Union[Types.CustomEnum, None]]\n    enumArray: List[Types.CustomEnum]\n    optEnumArray: Optional[Union[List[Union[Types.CustomEnum, None]], None]]\n    map: GenericMap[Types.String, Types.Int]\n    mapOfArr: GenericMap[Types.String, List[Types.Int]]\n    mapOfObj: GenericMap[Types.String, Types.AnotherType]\n    mapOfArrOfObj: GenericMap[Types.String, List[Types.AnotherType]]\n    mapCustomValue: GenericMap[Types.String, Optional[Types.CustomMapValue]]\n\nclass AnotherType(TypedDict):\n    prop: Optional[Union[Types.String, None]]\n    circular: Optional[Union[Types.CustomType, None]]\n    const: Optional[Union[Types.String, None]]\n\nclass CustomMapValue(TypedDict):\n    foo: Types.String\n\nclass _else(TypedDict):\n    else: Types.String\n\n### Objects END ###\n\n### Enums START ###\nclass CustomEnum(Enum):\n    STRING,\n    BYTES,\n\nclass while(Enum):\n    for,\n    in,\n\n### Enums END ###\n\n### Imported Objects START ###\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_Object(TypedDict):\n    object: Types.TestImport_AnotherObject;\n    optObject: Optional[Union[Types.TestImport_AnotherObject, None]];\n    objectArray: List[Types.TestImport_AnotherObject];\n    optObjectArray: Optional[Union[List[Union[Types.TestImport_AnotherObject, None]], None]];\n    en: Types.TestImport_Enum;\n    optEnum: Optional[Union[Types.TestImport_Enum, None]];\n    enumArray: List[Types.TestImport_Enum];\n    optEnumArray: Optional[Union[List[Union[Types.TestImport_Enum, None]], None]];\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_AnotherObject(TypedDict):\n    prop: Types.String;\n\n### Imported Objects END ###\n\n### Imported Enums START ###\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_Enum(Enum):\n    STRING,\n    BYTES,\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_Enum_Return(Enum):\n    STRING,\n    BYTES,\n\n\n### Imported Enums END ###\n\n### Imported Modules START ###\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_ModuleArgsimportedMethod(TypedDict):\n    str: Types.String;\n    optStr?: Union[Types.String, None];\n    u: Types.UInt;\n    optU?: Union[Types.UInt, None];\n    uArrayArray: List[Union[List[Union[Types.UInt, None]], None]];\n    object: Types.TestImport_Object;\n    optObject?: Union[Types.TestImport_Object, None];\n    objectArray: List[Types.TestImport_Object];\n    optObjectArray?: Union[List[Union[Types.TestImport_Object, None]], None];\n    en: Types.TestImport_Enum;\n    optEnum?: Union[Types.TestImport_Enum, None];\n    enumArray: List[Types.TestImport_Enum];\n    optEnumArray?: Union[List[Union[Types.TestImport_Enum, None]], None];\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_ModuleArgsanotherMethod(TypedDict):\n    arg: List[Types.String];\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_ModuleArgsreturnsArrayOfEnums(TypedDict):\n    arg: Types.String;\n\n/* URI: \"testimport.uri.eth\" */\nclass TestImport_Module:\n    INTERFACE_URI: Uri = Uri.from_str(\"testimport.uri.eth\")\n    uri: Uri\n\n    def __init__(uri: Uri) {\n      this.uri = uri\n    }\n\n    async def importedMethod(\n      self,\n      args: TestImport_ModuleArgsimportedMethod,\n      client: InvokerClient[UriPackageOrWrapper]\n    ): Union[Types.TestImport_Object, None]:\n        return client.invoke<Union[Types.TestImport_Object, None]>(\n            InvokeOptions(\n                uri=self.uri,\n                method=\"importedMethod\",\n                args=args,\n            )\n        );\n\n    async def anotherMethod(\n      self,\n      args: TestImport_ModuleArgsanotherMethod,\n      client: InvokerClient[UriPackageOrWrapper]\n    ): Types.Int32:\n        return client.invoke<Types.Int32>(\n            InvokeOptions(\n                uri=self.uri,\n                method=\"anotherMethod\",\n                args=args,\n            )\n        );\n\n    async def returnsArrayOfEnums(\n      self,\n      args: TestImport_ModuleArgsreturnsArrayOfEnums,\n      client: InvokerClient[UriPackageOrWrapper]\n    ): List[Union[Types.TestImport_Enum_Return, None]]:\n        return client.invoke<List[Union[Types.TestImport_Enum_Return, None]]>(\n            InvokeOptions(\n                uri=self.uri,\n                method=\"returnsArrayOfEnums\",\n                args=args,\n            )\n        );\n\n### Imported Modules END ###\n\n### Interface START ###\n\n\nclass TestImport:\n    URI: Uri = Uri.from_str(\"testimport.uri.eth\")\n\n    async def get_implementations(\n      client: InvokerClient[UriPackageOrWrapper]\n    ): string[] {\n        impls = await client.getImplementations(self.uri)\n        return [impl.uri for impl in impls]\n    }\n\n### Interface END ###\n"
      }
    ]
  },
  "outputDirAbs": "tester"
}